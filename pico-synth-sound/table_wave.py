import datetime
import math
from decimal import Decimal, ROUND_HALF_UP

MAX_VALUE = 65535
N_SAMPLE = 256
FREQ_SAMPLE = 40000
FREQ_LIMIT = [1250.0, 2500.0, 5000.0, 10000.0]
OUTPUT_PATH = "table_wave_auto.h"

today = datetime.datetime.now()

header_title = f"""
// This file was generated by a python script on {today.isoformat()}
#ifndef TABLE_WAVE_H
#define TABLE_WAVE_H

#include "pico/stdlib.h"
#include "hardware/interp.h"
#include "fixed_point.hpp"

"""

header_bottom = """
inline int32_t pick_table(const int32_t wave[256], uint16_t index)
{
    interp0->base[0] = wave[index >> 8];
    interp0->base[1] = wave[(index + 1) >> 8];
    interp0->accum[1] = index & 0xFF;
    return interp0->peek[1];
}

inline int32_t mix_values(int32_t a, int32_t b, uint8_t mix = 127)
{
    interp0->base[0] = a;
    interp0->base[1] = b;
    interp0->accum[1] = mix;
    return interp0->peek[1];
}

inline Fixed_16_16 get_wave_sine(uint16_t phase16)
{
    return Fixed_16_16::from_raw_value(pick_table(wave_sine, phase16));
}

inline Fixed_16_16 get_wave_saw(uint16_t phase16, uint16_t phase16_delta)
{
    int32_t y;
    if (phase16_delta >> 15)
    {
        y = pick_table(wave_sine, phase16);
    }
    else if (phase16_delta >> 14)
    {
        y = mix_values(pick_table(wave_saw_2, phase16),
                       pick_table(wave_sine, phase16),
                       static_cast<uint8_t>(phase16_delta >> 6));
    }
    else if (phase16_delta >> 13)
    {
        y = mix_values(pick_table(wave_saw_4, phase16),
                       pick_table(wave_saw_2, phase16),
                       static_cast<uint8_t>(phase16_delta >> 5));
    }
    else if (phase16_delta >> 12)
    {
        y = mix_values(pick_table(wave_saw_8, phase16),
                       pick_table(wave_saw_4, phase16),
                       static_cast<uint8_t>(phase16_delta >> 4));
    }
    else if (phase16_delta >> 11)
    {
        y = mix_values(pick_table(wave_saw_16, phase16),
                       pick_table(wave_saw_8, phase16),
                       static_cast<uint8_t>(phase16_delta >> 3));
    }
    else if (phase16_delta >> 10)
    {
        y = mix_values(pick_table(wave_saw_32, phase16),
                       pick_table(wave_saw_16, phase16),
                       static_cast<uint8_t>(phase16_delta >> 2));
    }
    else if (phase16_delta >> 9)
    {
        y = mix_values(pick_table(wave_saw_64, phase16),
                       pick_table(wave_saw_32, phase16),
                       static_cast<uint8_t>(phase16_delta >> 1));
    }
    else if (phase16_delta >> 8)
    {
        y = mix_values(pick_table(wave_saw_128, phase16),
                       pick_table(wave_saw_64, phase16),
                       static_cast<uint8_t>(phase16_delta));
    }
    else
    {
        y = pick_table(wave_saw_128, phase16);
    }

    return Fixed_16_16::from_raw_value(y);
}

inline Fixed_16_16 get_wave_tri(uint16_t phase16, uint16_t phase16_delta)
{
    int32_t y;
    if (phase16_delta >> 15)
    {
        y = pick_table(wave_sine, phase16);
    }
    else if (phase16_delta >> 14)
    {
        y = mix_values(pick_table(wave_tri_2, phase16),
                       pick_table(wave_sine, phase16),
                       static_cast<uint8_t>(phase16_delta >> 6));
    }
    else if (phase16_delta >> 13)
    {
        y = mix_values(pick_table(wave_tri_4, phase16),
                       pick_table(wave_tri_2, phase16),
                       static_cast<uint8_t>(phase16_delta >> 5));
    }
    else if (phase16_delta >> 12)
    {
        y = mix_values(pick_table(wave_tri_8, phase16),
                       pick_table(wave_tri_4, phase16),
                       static_cast<uint8_t>(phase16_delta >> 4));
    }
    else if (phase16_delta >> 11)
    {
        y = mix_values(pick_table(wave_tri_16, phase16),
                       pick_table(wave_tri_8, phase16),
                       static_cast<uint8_t>(phase16_delta >> 3));
    }
    else if (phase16_delta >> 10)
    {
        y = mix_values(pick_table(wave_tri_32, phase16),
                       pick_table(wave_tri_16, phase16),
                       static_cast<uint8_t>(phase16_delta >> 2));
    }
    else if (phase16_delta >> 9)
    {
        y = mix_values(pick_table(wave_tri_64, phase16),
                       pick_table(wave_tri_32, phase16),
                       static_cast<uint8_t>(phase16_delta >> 1));
    }
    else if (phase16_delta >> 8)
    {
        y = mix_values(pick_table(wave_tri_128, phase16),
                       pick_table(wave_tri_64, phase16),
                       static_cast<uint8_t>(phase16_delta));
    }
    else
    {
        y = pick_table(wave_tri_128, phase16);
    }

    return Fixed_16_16::from_raw_value(y);
}

#endif

"""


def remove_exponent(d):
    return d.quantize(Decimal(1)) if d == d.to_integral() else d.normalize()


def to_rounded_int(x):
    d = Decimal(str(x)).quantize(Decimal(), ROUND_HALF_UP)
    return int(remove_exponent(d))


def get_sine(x):
    y = math.sin(2 * math.pi * x / N_SAMPLE) * MAX_VALUE
    return y


def get_saw(x, n):
    y = 0.0
    for k in range(1, n + 1):
        a = math.cos(0.5 * math.pi * (k - 1) / n) ** 2  # for Gibbs effect
        y += a * (2.0 / math.pi) * math.sin(2 * math.pi * k * x / N_SAMPLE) / k
    return y * MAX_VALUE


def get_tri(x, n):
    y = 0.0
    for k in range(1, n + 1):
        a = math.cos(0.5 * math.pi * (k - 1) / n) ** 2  # for Gibbs effect
        y += (
            a
            * (8.0 / k**2)
            * math.sin(math.pi * k / 2.0)
            * math.sin(2 * math.pi * k * x / N_SAMPLE)
            / k
        )
    return y * MAX_VALUE


with open(OUTPUT_PATH, "w") as f:
    f.write(header_title)

    # Sine wave
    table_sine = [to_rounded_int(get_sine(x)) for x in range(N_SAMPLE)]
    assert max(table_sine) <= MAX_VALUE
    assert min(table_sine) >= -MAX_VALUE
    const_table_sine = (
        f"const int32_t wave_sine[{N_SAMPLE}] = "
        + "{"
        + ", ".join(map(str, table_sine))
        + "};\n"
    )
    f.write(const_table_sine)

    # Saw wave
    for n in range(1, 8):
        table_saw = [get_saw(x, 2**n) for x in range(N_SAMPLE)]
        table_saw_max = max(table_saw) / MAX_VALUE
        table_saw = [
            to_rounded_int(y / table_saw_max) for y in table_saw
        ]  # normalize to 1
        assert max(table_saw) <= MAX_VALUE
        assert min(table_saw) >= -MAX_VALUE
        const_table_saw = (
            f"const int32_t wave_saw_{2**n}[{N_SAMPLE}] = "
            + "{"
            + ", ".join(map(str, table_saw))
            + "};\n"
        )
        f.write(const_table_saw)

    # Triangle wave
    for n in range(1, 8):
        table_tri = [get_tri(x, 2**n) for x in range(N_SAMPLE)]
        table_tri_max = max(table_tri) / MAX_VALUE
        table_tri = [
            to_rounded_int(y / table_tri_max) for y in table_tri
        ]  # normalize to 1
        assert max(table_tri) <= MAX_VALUE
        assert min(table_tri) >= -MAX_VALUE
        const_table_tri = (
            f"const int32_t wave_tri_{2**n}[{N_SAMPLE}] = "
            + "{"
            + ", ".join(map(str, table_tri))
            + "};\n"
        )
        f.write(const_table_tri)
    f.write(header_bottom)
